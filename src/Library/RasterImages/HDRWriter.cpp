//////////////////////////////////////////////////////////////////////
//
//  HDRWriter.cpp - Implementation of the HDRWriter class
//
//  Author: Aravind Krishnaswamy
//  Date of Birth: November 17, 2003
//  Tabs: 4
//  Comments:
//
//  License Information: Please see the attached LICENSE.TXT file
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>					// for sprintf
#include <string.h>					// for strlen and strncmp
#include "HDRWriter.h"
#include "../Interfaces/ILog.h"
#include "../Version.h"

using namespace RISE;
using namespace RISE::Implementation;

HDRWriter::HDRWriter( IWriteBuffer& buffer, const COLOR_SPACE color_space_ ) :
  pWriteBuffer( buffer ),
  pBuffer( 0 ),
  color_space( color_space_ )
{
	pWriteBuffer.addref();
}

HDRWriter::~HDRWriter( )
{
	pWriteBuffer.release();

	if( pBuffer ) {
		GlobalLog()->PrintDelete( pBuffer, __FILE__, __LINE__ );
		delete [] pBuffer;
		pBuffer = 0;
	}
}

void HDRWriter::BeginWrite( const unsigned int width, const unsigned int height )
{
	// Build the header
	char szHeader[2048] = {0};
	{
		static const char * szSignature = "#?RADIANCE\n";
		char szWhoWroteIt[256] = {0};
		sprintf( szWhoWroteIt, "# Generated by R.I.S.E. v%d.%d.%d build %d\n", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );
		static const char * szImageType = "FORMAT=32-bit_rle_rgbe\n\n";
		char szImageDimensions[256] = {0};
		sprintf( szImageDimensions,"-Y %d +X %d\n", height, width );

		strcpy( szHeader, szSignature );
		strcat( szHeader, szWhoWroteIt );
		strcat( szHeader, szImageType );
		strcat( szHeader, szImageDimensions );
	}

	// Write the header
	// Make sure there's enough room in the buffer first
	pWriteBuffer.Resize( width*height*4 + strlen(szHeader) );

	// Write out the header
	pWriteBuffer.setBytes( szHeader, strlen(szHeader) );

	// Setup the buffer
	bufW = width;
	bufH = height;
	pBuffer = new unsigned char[width*height*4];
	GlobalLog()->PrintNew( pBuffer, __FILE__, __LINE__, "buffer" );
}

void HDRWriter::WriteColor( const RISEColor& c, const unsigned int x, const unsigned int y )
{
	if( pBuffer ) {
		// No alpha in RGBE, so composite against black

		switch( color_space )
		{
		case eColorSpace_Rec709RGB_Linear:
			{
				Rec709RGBPel p = Rec709RGBPel(c.base) * c.a;
				WriteHDRPixelToBuffer( x, y, p );
			} break;
		case eColorSpace_sRGB:
			{
				sRGBPel p = sRGBPel(c.base) * c.a;
				WriteHDRPixelToBuffer( x, y, p );
			} break;
		case eColorSpace_ROMMRGB_Linear:
			{
				ROMMRGBPel p = ROMMRGBPel(c.base) * c.a;
				WriteHDRPixelToBuffer( x, y, p );
			} break;
		case eColorSpace_ProPhotoRGB:
			{
				ProPhotoRGBPel p = ProPhotoRGBPel(c.base) * c.a;
				WriteHDRPixelToBuffer( x, y, p );
			} break;
		}
	}
}

void HDRWriter::EndWrite( )
{
	// We aren't going to bother with any of the RLE stuff, just
	// write everything out as raw data

	// !@@ TODO RLE our data, if its really necessary
	pWriteBuffer.setBytes( pBuffer, bufW*bufH*4 );
}
