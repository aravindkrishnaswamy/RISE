//////////////////////////////////////////////////////////////////////
//
//  RGBEAWriter.cpp - Implementation of the RGBEAWriter class
//                
//  Author: Aravind Krishnaswamy
//  Date of Birth: February 4, 2004
//  Tabs: 4
//  Comments:
//
//  License Information: Please see the attached LICENSE.TXT file
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>					// for sprintf
#include <string.h>					// for strlen and strncmp
#include "RGBEAWriter.h"
#include "../Interfaces/ILog.h"
#include "../Version.h"

using namespace RISE;
using namespace RISE::Implementation;

RGBEAWriter::RGBEAWriter( IWriteBuffer& buffer ) :
  pWriteBuffer( buffer ),
  pBuffer( 0 )
{
	pWriteBuffer.addref();
}

RGBEAWriter::~RGBEAWriter( )
{
	pWriteBuffer.release();

	if( pBuffer ) {
		GlobalLog()->PrintDelete( pBuffer, __FILE__, __LINE__ );
		delete [] pBuffer;
		pBuffer = 0;
	}
}

void RGBEAWriter::BeginWrite( const unsigned int width, const unsigned int height )
{
	// Build the header
	char szHeader[2048] = {0};
	{
		static const char * szSignature = "#?RGBEA\n";
		char szWhoWroteIt[256] = {0};
		sprintf( szWhoWroteIt, "# Generated by R.I.S.E. v%d.%d.%d build %d\n", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );
		static const char * szImageType = "FORMAT=64-bit_rle_rgbea\n\n";
		char szImageDimensions[256] = {0};
		sprintf( szImageDimensions,"-Y %d +X %d\n", height, width );

		strcpy( szHeader, szSignature );
		strcat( szHeader, szWhoWroteIt );
		strcat( szHeader, szImageType );
		strcat( szHeader, szImageDimensions );
	}	

	// Write the header
	// Make sure there's enough room in the buffer first
	pWriteBuffer.Resize( width*height*8 + strlen(szHeader) );

	// Write out the header
	pWriteBuffer.setBytes( szHeader, strlen(szHeader) );

	// Setup the buffer
	bufW = width;
	bufH = height;
	pBuffer = new unsigned char[width*height*8];
	GlobalLog()->PrintNew( pBuffer, __FILE__, __LINE__, "buffer" );
}

void RGBEAWriter::WriteColor( const RISEColor& c, const unsigned int x, const unsigned int y )
{
	const unsigned char RGBEBase = 128;

	if( pBuffer ) {
		// Unlike the RGBE and HDR formats, our RGBEA format is in the ROMM RGB color space
		ROMMRGBPel p = c.base;
		Scalar v = ColorMath::MaxValue(p);
		int e;

		const unsigned int idx = y*bufW*8+x*8;

		if( v < 1e-32 ) {
			//R
			pBuffer[idx] = 0;
			pBuffer[idx+1] = 0;
			//G
			pBuffer[idx+2] = 0;
			pBuffer[idx+3] = 0;
			//B
			pBuffer[idx+4] = 0;
			pBuffer[idx+5] = 0;
			//E
			pBuffer[idx+6] = 0;
			//A
			pBuffer[idx+7] = 0;
		} else {
			v = frexp(v,&e) * 65536.0/v;
#ifndef RISE_BIG_ENDIAN
			*((unsigned short*)(&pBuffer[idx])) = (unsigned short)(p.r*v);
			*((unsigned short*)(&pBuffer[idx+2])) = (unsigned short)(p.g*v);
			*((unsigned short*)(&pBuffer[idx+4])) = (unsigned short)(p.b*v);
#else
			unsigned short tempR = (unsigned short)(p.r*v);
			pBuffer[idx] = ((tempR>>8)&0xFF);
			pBuffer[idx+1] = (tempR&0xFF);
			unsigned short tempG = (unsigned short)(p.g*v);
			pBuffer[idx+2] = ((tempG>>8)&0xFF);
			pBuffer[idx+3] = (tempG&0xFF);
			unsigned short tempB = (unsigned short)(p.b*v);
			pBuffer[idx+4] = ((tempB>>8)&0xFF);
			pBuffer[idx+5] = (tempB&0xFF);
#endif
			pBuffer[idx+6] = (e + RGBEBase);
			pBuffer[idx+7] = (unsigned char)(c.a*255.0);
		}
	}
}

void RGBEAWriter::EndWrite( )
{
	pWriteBuffer.setBytes( pBuffer, bufW*bufH*8 );
}
